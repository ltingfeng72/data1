# 图书管理系统测试指南

## 目录
1. [测试环境准备](#测试环境准备)
2. [测试工具清单](#测试工具清单)
3. [数据库测试](#数据库测试)
4. [应用程序测试](#应用程序测试)
5. [功能测试](#功能测试)
6. [性能测试](#性能测试)
7. [安全测试](#安全测试)
8. [测试用例清单](#测试用例清单)

---

## 测试环境准备

### 1. 安装必需软件

#### Windows 环境
```cmd
# 检查 MySQL 是否安装
mysql --version

# 检查 C++ 编译器
g++ --version
# 或
cl

# 检查 ODBC 驱动
odbcconf /q
```

#### Linux 环境
```bash
# 安装测试工具
sudo apt-get update
sudo apt-get install mysql-client mysql-server
sudo apt-get install unixodbc unixodbc-dev libmyodbc
sudo apt-get install g++ build-essential

# 验证安装
mysql --version
g++ --version
odbcinst -j
```

### 2. 配置测试数据库

```sql
-- 创建测试数据库
CREATE DATABASE library_test CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- 使用测试数据库
USE library_test;

-- 导入数据库架构
SOURCE /path/to/database/schema.sql;

-- 验证表创建
SHOW TABLES;
```

---

## 测试工具清单

### 必需工具

| 工具 | 用途 | 安装命令 |
|------|------|----------|
| MySQL Client | 数据库操作和查询 | `sudo apt-get install mysql-client` |
| MySQL Workbench | 可视化数据库管理 | 下载安装包 |
| GDB / LLDB | C++ 调试器 | `sudo apt-get install gdb` |
| Valgrind | 内存泄漏检测 | `sudo apt-get install valgrind` |
| ODBC Administrator | ODBC 配置管理 | Windows 自带 / unixODBC |

### 可选工具

| 工具 | 用途 | 安装方法 |
|------|------|----------|
| DBeaver | 跨平台数据库客户端 | https://dbeaver.io/ |
| HeidiSQL | MySQL 管理工具 (Windows) | https://www.heidisql.com/ |
| Postman | API 测试（如果扩展） | https://www.postman.com/ |
| JMeter | 性能测试工具 | https://jmeter.apache.org/ |

---

## 数据库测试

### 1. 数据库架构验证

#### 步骤 1: 连接数据库
```bash
mysql -u root -p library_test
```

#### 步骤 2: 验证表结构
```sql
-- 查看所有表
SHOW TABLES;

-- 期望输出：
-- +------------------------+
-- | Tables_in_library_test |
-- +------------------------+
-- | bookrack               |
-- | books                  |
-- | borrow                 |
-- | reader                 |
-- | users                  |
-- +------------------------+

-- 验证每个表的结构
DESCRIBE users;
DESCRIBE bookrack;
DESCRIBE books;
DESCRIBE reader;
DESCRIBE borrow;
```

#### 步骤 3: 验证外键约束
```sql
-- 查看外键关系
SELECT 
    TABLE_NAME,
    COLUMN_NAME,
    CONSTRAINT_NAME,
    REFERENCED_TABLE_NAME,
    REFERENCED_COLUMN_NAME
FROM
    INFORMATION_SCHEMA.KEY_COLUMN_USAGE
WHERE
    REFERENCED_TABLE_SCHEMA = 'library_test';
```

#### 步骤 4: 验证索引
```sql
-- 查看索引
SHOW INDEX FROM books;
SHOW INDEX FROM borrow;
SHOW INDEX FROM users;
```

### 2. 数据完整性测试

#### 测试用例 1: 外键约束测试
```sql
-- 测试：尝试插入不存在的 bookrackId 的图书（应该失败）
INSERT INTO books (bookName, bookrackId, roomId) 
VALUES ('测试图书', 999, 101);
-- 期望：错误 - 违反外键约束

-- 测试：插入有效的图书
INSERT INTO books (bookName, bookrackId, roomId) 
VALUES ('测试图书', 1, 101);
-- 期望：成功

-- 清理测试数据
DELETE FROM books WHERE bookName = '测试图书';
```

#### 测试用例 2: 唯一约束测试
```sql
-- 测试：尝试插入重复的用户名（应该失败）
INSERT INTO users (username, password, role) 
VALUES ('admin', 'test123', 'admin');
-- 期望：错误 - 违反唯一约束
```

#### 测试用例 3: 级联删除测试
```sql
-- 测试：删除读者时，相关借阅记录应被删除
START TRANSACTION;

-- 查看删除前的借阅记录
SELECT COUNT(*) FROM borrow WHERE browBookId = 1001;

-- 删除读者
DELETE FROM reader WHERE borrowBookId = 1001;

-- 验证借阅记录也被删除
SELECT COUNT(*) FROM borrow WHERE browBookId = 1001;
-- 期望：0

ROLLBACK; -- 回滚测试
```

### 3. 数据查询性能测试

```sql
-- 测试查询性能
EXPLAIN SELECT * FROM books WHERE bookName LIKE '%C++%';

-- 测试连接查询
EXPLAIN SELECT b.bookId, bk.bookName, b.borrowDate 
FROM borrow b 
JOIN books bk ON b.bookId = bk.bookId 
WHERE b.browBookId = 1001;

-- 验证索引使用
SHOW INDEX FROM books;
```

---

## 应用程序测试

### 1. 编译测试

#### Windows (Visual Studio)
```cmd
cd src
cl main.cpp odbc32.lib /EHsc /W4

# 期望：无编译错误
# 生成：main.exe
```

#### Windows (MinGW)
```cmd
cd src
g++ -o library_system.exe main.cpp -lodbc32 -Wall -Wextra

# 期望：无编译警告和错误
```

#### Linux
```bash
cd src
g++ -o library_system main.cpp -lodbc -std=c++11 -Wall -Wextra -g

# 期望：无编译警告和错误
# -g 参数用于生成调试信息
```

### 2. ODBC 连接测试

#### 步骤 1: 验证 ODBC 配置
```bash
# Linux
odbcinst -q -s
# 应该看到 LibraryDB 数据源

# 测试连接
isql LibraryDB root password
```

#### 步骤 2: 测试程序连接
```bash
# 运行程序
./library_system

# 预期输出：
# ========================================
#       图书管理系统登录
# ========================================
# 数据库连接成功！
# 用户名:
```

### 3. 内存泄漏检测 (Linux)

```bash
# 使用 Valgrind 检测内存泄漏
valgrind --leak-check=full --show-leak-kinds=all ./library_system

# 检查输出中的内存泄漏报告
# 期望：无内存泄漏
```

### 4. 调试测试

```bash
# 使用 GDB 调试
gdb ./library_system

# GDB 命令：
(gdb) break main           # 在 main 函数设置断点
(gdb) run                  # 运行程序
(gdb) next                 # 单步执行
(gdb) print currentUser    # 打印变量值
(gdb) continue             # 继续执行
(gdb) quit                 # 退出
```

---

## 功能测试

### 1. 用户登录功能测试

#### 测试用例 1.1: 正常登录
```
操作步骤：
1. 运行程序：./library_system
2. 输入用户名：admin
3. 输入密码：admin123

预期结果：
✓ 显示"登录成功！欢迎 admin"
✓ 显示管理员菜单
✓ 显示三个选项：1.添加图书 2.删除图书 3.修改图书信息

实际结果：[记录实际输出]
测试状态：[ ] 通过  [ ] 失败
```

#### 测试用例 1.2: 错误密码
```
操作步骤：
1. 运行程序：./library_system
2. 输入用户名：admin
3. 输入密码：wrongpassword

预期结果：
✓ 显示"登录失败：用户名或密码错误"
✓ 程序退出

实际结果：[记录实际输出]
测试状态：[ ] 通过  [ ] 失败
```

#### 测试用例 1.3: 不存在的用户
```
操作步骤：
1. 运行程序：./library_system
2. 输入用户名：nonexistent
3. 输入密码：anypassword

预期结果：
✓ 显示"登录失败：用户名或密码错误"
✓ 程序退出

实际结果：[记录实际输出]
测试状态：[ ] 通过  [ ] 失败
```

### 2. 管理员功能测试

#### 测试用例 2.1: 添加图书
```
前置条件：以 admin/admin123 登录

操作步骤：
1. 选择菜单选项：1
2. 输入图书名称：测试图书A
3. 输入出版日期：2024-01-01
4. 输入出版社：测试出版社
5. 输入书架ID：1
6. 输入房间ID：101

预期结果：
✓ 显示"图书添加成功！"
✓ 返回主菜单

验证步骤：
在数据库中查询：
SELECT * FROM books WHERE bookName = '测试图书A';

清理步骤：
DELETE FROM books WHERE bookName = '测试图书A';

实际结果：[记录实际输出]
测试状态：[ ] 通过  [ ] 失败
```

#### 测试用例 2.2: 删除图书
```
前置条件：
1. 以 admin/admin123 登录
2. 数据库中存在图书ID=1

操作步骤：
1. 选择菜单选项：2
2. 输入图书ID：1

预期结果：
✓ 显示"图书删除成功！"
✓ 返回主菜单

验证步骤：
SELECT * FROM books WHERE bookId = 1;
-- 应该返回空结果

注意：这是破坏性测试，需要提前备份数据

实际结果：[记录实际输出]
测试状态：[ ] 通过  [ ] 失败
```

#### 测试用例 2.3: 修改图书
```
前置条件：
1. 以 admin/admin123 登录
2. 数据库中存在图书ID=2

操作步骤：
1. 选择菜单选项：3
2. 输入图书ID：2
3. 输入新图书名称：修改后的书名
4. 输入新出版社：修改后的出版社

预期结果：
✓ 显示"图书信息修改成功！"
✓ 返回主菜单

验证步骤：
SELECT bookName, publisher FROM books WHERE bookId = 2;
-- 应该显示更新后的值

实际结果：[记录实际输出]
测试状态：[ ] 通过  [ ] 失败
```

### 3. 操作员功能测试

#### 测试用例 3.1: 借书登记
```
前置条件：
1. 以 operator/oper123 登录
2. 数据库中存在读者ID=1001
3. 数据库中存在图书ID=1

操作步骤：
1. 选择菜单选项：1
2. 输入读者ID：1001
3. 输入图书ID：1

预期结果：
✓ 显示"借书登记成功！"
✓ 返回主菜单

验证步骤：
SELECT * FROM borrow 
WHERE browBookId = 1001 AND bookId = 1 AND returnDate IS NULL;
-- 应该有一条记录

清理步骤：
DELETE FROM borrow 
WHERE browBookId = 1001 AND bookId = 1 AND returnDate IS NULL;

实际结果：[记录实际输出]
测试状态：[ ] 通过  [ ] 失败
```

#### 测试用例 3.2: 还书登记
```
前置条件：
1. 以 operator/oper123 登录
2. 读者1001已借阅图书1（returnDate IS NULL）

操作步骤：
1. 选择菜单选项：2
2. 输入读者ID：1001
3. 输入图书ID：1

预期结果：
✓ 显示"还书登记成功！"
✓ 返回主菜单

验证步骤：
SELECT returnDate FROM borrow 
WHERE browBookId = 1001 AND bookId = 1
ORDER BY borrowDate DESC LIMIT 1;
-- returnDate 应该不为 NULL

实际结果：[记录实际输出]
测试状态：[ ] 通过  [ ] 失败
```

### 4. 读者功能测试

#### 测试用例 4.1: 查询所有图书
```
前置条件：以 reader1/read123 登录

操作步骤：
1. 选择菜单选项：1
2. 直接按回车（查询所有）

预期结果：
✓ 显示"图书列表："
✓ 显示多条图书记录
✓ 每条记录包含：ID, 书名, 出版社, 日期, 书架, 房间
✓ 返回主菜单

实际结果：[记录实际输出]
测试状态：[ ] 通过  [ ] 失败
```

#### 测试用例 4.2: 关键字查询图书
```
前置条件：以 reader1/read123 登录

操作步骤：
1. 选择菜单选项：1
2. 输入关键字：C++

预期结果：
✓ 显示"图书列表："
✓ 只显示书名包含"C++"的图书
✓ 返回主菜单

实际结果：[记录实际输出]
测试状态：[ ] 通过  [ ] 失败
```

#### 测试用例 4.3: 查看借阅记录
```
前置条件：
1. 以 reader1/read123 登录
2. 数据库中存在读者1001的借阅记录

操作步骤：
1. 选择菜单选项：2
2. 输入读者ID：1001

预期结果：
✓ 显示"借阅记录："
✓ 显示该读者的所有借阅记录
✓ 对于未归还的书，显示"状态: 未归还"
✓ 对于已归还的书，显示还书日期
✓ 返回主菜单

实际结果：[记录实际输出]
测试状态：[ ] 通过  [ ] 失败
```

### 5. 权限控制测试

#### 测试用例 5.1: 角色权限隔离
```
测试 1：操作员尝试添加图书（应该失败）
前置条件：以 operator/oper123 登录

操作步骤：
1. 观察菜单选项

预期结果：
✓ 菜单只显示：1.借书登记 2.还书登记
✓ 没有添加/删除/修改图书的选项

测试状态：[ ] 通过  [ ] 失败

---

测试 2：读者尝试借书操作（应该失败）
前置条件：以 reader1/read123 登录

操作步骤：
1. 观察菜单选项

预期结果：
✓ 菜单只显示：1.查询图书 2.查看借阅记录
✓ 没有借书还书的选项

测试状态：[ ] 通过  [ ] 失败
```

---

## 性能测试

### 1. 响应时间测试

#### 工具：自定义测试脚本

创建测试脚本 `test_performance.sh`：
```bash
#!/bin/bash

echo "性能测试开始..."

# 测试登录响应时间
start=$(date +%s.%N)
echo -e "admin\nadmin123\n0\n" | ./library_system > /dev/null
end=$(date +%s.%N)
login_time=$(echo "$end - $start" | bc)

echo "登录响应时间: ${login_time}秒"
# 期望：< 1秒

# 测试查询响应时间
mysql -u root -p library_test -e "
SET profiling = 1;
SELECT * FROM books WHERE bookName LIKE '%C++%';
SHOW PROFILES;
"
```

### 2. 并发测试

```bash
# 创建并发测试脚本
for i in {1..10}; do
    ./library_system &
done

# 监控系统资源
top -b -n 1 | grep library_system
```

### 3. 负载测试

```sql
-- 插入大量测试数据
DELIMITER //
CREATE PROCEDURE insert_test_books()
BEGIN
    DECLARE i INT DEFAULT 0;
    WHILE i < 1000 DO
        INSERT INTO books (bookName, publisher, bookrackId, roomId)
        VALUES (CONCAT('测试图书', i), '测试出版社', 1, 101);
        SET i = i + 1;
    END WHILE;
END//
DELIMITER ;

CALL insert_test_books();

-- 测试大量数据查询性能
SELECT SQL_NO_CACHE * FROM books WHERE bookName LIKE '%500%';

-- 清理测试数据
DELETE FROM books WHERE bookName LIKE '测试图书%';
```

---

## 安全测试

### 1. SQL 注入测试

#### 测试用例 6.1: 登录 SQL 注入
```
操作步骤：
1. 运行程序
2. 用户名输入：admin' OR '1'='1
3. 密码输入：任意

预期结果：
✓ 登录失败（当前实现可能有漏洞）
✓ 不应该绕过认证

注意：这是测试系统漏洞，实际发现问题需要修复代码

实际结果：[记录实际输出]
安全等级：[ ] 安全  [ ] 有漏洞
```

#### 测试用例 6.2: 图书查询 SQL 注入
```
前置条件：以 reader1/read123 登录

操作步骤：
1. 选择查询图书
2. 输入关键字：' OR '1'='1

预期结果：
✓ 应该正常处理，不泄露所有数据
✓ 或显示错误但不崩溃

实际结果：[记录实际输出]
安全等级：[ ] 安全  [ ] 有漏洞
```

### 2. 缓冲区溢出测试

```
操作步骤：
1. 登录系统
2. 尝试输入超长字符串（>256字符）

测试点：
- 用户名
- 密码
- 图书名称
- 出版社名称
- 地址

预期结果：
✓ 程序不崩溃
✓ 正常处理或提示错误

实际结果：[记录实际输出]
安全等级：[ ] 安全  [ ] 有问题
```

---

## 测试用例清单

### 功能测试清单

| ID | 测试项 | 优先级 | 状态 | 备注 |
|----|--------|--------|------|------|
| TC-01 | 管理员正常登录 | P0 | [ ] | 核心功能 |
| TC-02 | 错误密码登录 | P0 | [ ] | 核心功能 |
| TC-03 | 添加图书 | P0 | [ ] | 管理员功能 |
| TC-04 | 删除图书 | P0 | [ ] | 管理员功能 |
| TC-05 | 修改图书 | P0 | [ ] | 管理员功能 |
| TC-06 | 借书登记 | P0 | [ ] | 操作员功能 |
| TC-07 | 还书登记 | P0 | [ ] | 操作员功能 |
| TC-08 | 查询图书 | P0 | [ ] | 读者功能 |
| TC-09 | 查看借阅记录 | P0 | [ ] | 读者功能 |
| TC-10 | 权限隔离 | P1 | [ ] | 安全功能 |
| TC-11 | 数据完整性 | P1 | [ ] | 数据库测试 |
| TC-12 | 外键约束 | P1 | [ ] | 数据库测试 |

### 性能测试清单

| ID | 测试项 | 指标 | 状态 | 实际值 |
|----|--------|------|------|--------|
| PT-01 | 登录响应时间 | < 1s | [ ] | _____s |
| PT-02 | 查询响应时间 | < 2s | [ ] | _____s |
| PT-03 | 并发用户 | 10 用户 | [ ] | _____ |
| PT-04 | 大数据查询 | 1000+ 记录 | [ ] | _____s |

### 安全测试清单

| ID | 测试项 | 优先级 | 状态 | 风险等级 |
|----|--------|--------|------|----------|
| ST-01 | SQL 注入 - 登录 | P0 | [ ] | 高 |
| ST-02 | SQL 注入 - 查询 | P0 | [ ] | 高 |
| ST-03 | 缓冲区溢出 | P1 | [ ] | 中 |
| ST-04 | 内存泄漏 | P1 | [ ] | 中 |
| ST-05 | 密码明文存储 | P2 | [ ] | 低（已知） |

---

## 测试报告模板

### 测试执行报告

```
=====================================
图书管理系统测试报告
=====================================

测试日期：________
测试人员：________
测试版本：________

一、测试环境
- 操作系统：________
- MySQL 版本：________
- 编译器版本：________
- ODBC 版本：________

二、测试概要
- 计划测试用例数：____
- 实际执行用例数：____
- 通过用例数：____
- 失败用例数：____
- 通过率：____%

三、功能测试结果
[ ] 登录功能：通过 / 失败
[ ] 管理员功能：通过 / 失败
[ ] 操作员功能：通过 / 失败
[ ] 读者功能：通过 / 失败

四、性能测试结果
- 登录响应时间：____s (标准: <1s)
- 查询响应时间：____s (标准: <2s)
- 并发处理能力：____ 用户

五、安全测试结果
- SQL 注入测试：[ ] 通过 [ ] 存在漏洞
- 缓冲区溢出：[ ] 通过 [ ] 存在问题
- 内存泄漏：[ ] 无泄漏 [ ] 有泄漏

六、缺陷汇总
| 缺陷ID | 严重程度 | 描述 | 状态 |
|--------|----------|------|------|
| BUG-01 | 高/中/低 |      | 待修复 |

七、测试建议
1. ________
2. ________
3. ________

八、测试结论
[ ] 通过测试，可以发布
[ ] 部分通过，需要修复后再测
[ ] 未通过测试，需要重大修改
```

---

## 自动化测试脚本

### Python 测试脚本示例

创建 `test_automation.py`：
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
图书管理系统自动化测试脚本
"""

import mysql.connector
import subprocess
import time

class LibrarySystemTest:
    def __init__(self):
        self.db = mysql.connector.connect(
            host="localhost",
            user="root",
            password="password",
            database="library_test"
        )
        self.cursor = self.db.cursor()
        
    def test_database_schema(self):
        """测试数据库架构"""
        print("测试数据库架构...")
        
        # 检查表是否存在
        tables = ['users', 'bookrack', 'books', 'reader', 'borrow']
        self.cursor.execute("SHOW TABLES")
        result = [table[0] for table in self.cursor.fetchall()]
        
        for table in tables:
            assert table in result, f"表 {table} 不存在"
            print(f"✓ 表 {table} 存在")
            
    def test_foreign_keys(self):
        """测试外键约束"""
        print("\n测试外键约束...")
        
        try:
            # 尝试插入无效的外键
            self.cursor.execute(
                "INSERT INTO books (bookName, bookrackId, roomId) "
                "VALUES ('测试', 9999, 101)"
            )
            self.db.commit()
            print("✗ 外键约束失败")
            return False
        except mysql.connector.Error:
            print("✓ 外键约束正常工作")
            return True
            
    def test_user_authentication(self):
        """测试用户认证"""
        print("\n测试用户认证...")
        
        # 查询管理员用户
        self.cursor.execute(
            "SELECT username, role FROM users "
            "WHERE username='admin' AND password='admin123'"
        )
        result = self.cursor.fetchone()
        
        assert result is not None, "管理员用户不存在"
        assert result[1] == 'admin', "用户角色不正确"
        print("✓ 用户认证数据正确")
        
    def run_all_tests(self):
        """运行所有测试"""
        print("="*50)
        print("开始自动化测试")
        print("="*50)
        
        try:
            self.test_database_schema()
            self.test_foreign_keys()
            self.test_user_authentication()
            print("\n" + "="*50)
            print("所有测试完成！")
            print("="*50)
        finally:
            self.cursor.close()
            self.db.close()

if __name__ == "__main__":
    test = LibrarySystemTest()
    test.run_all_tests()
```

运行测试：
```bash
chmod +x test_automation.py
python3 test_automation.py
```

---

## 测试最佳实践

### 1. 测试前准备
- [ ] 备份生产数据库
- [ ] 使用独立的测试数据库
- [ ] 准备测试数据
- [ ] 记录初始状态

### 2. 测试执行
- [ ] 按照测试用例逐项测试
- [ ] 记录所有测试结果
- [ ] 对失败的测试截图保存
- [ ] 记录错误信息

### 3. 测试后清理
- [ ] 删除测试数据
- [ ] 恢复数据库状态
- [ ] 编写测试报告
- [ ] 提交缺陷报告

### 4. 回归测试
- [ ] 修复 bug 后重新测试
- [ ] 验证修复效果
- [ ] 确保没有引入新问题

---

**测试文档版本**: v1.0  
**最后更新**: 2024-12-18  
**适用系统**: 图书管理系统 RBAC v1.0
